/**
 * Generated by orval v7.15.0 🍺
 * Do not edit manually.
 * Hefesto API
 * Hardware listings
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { customAxios } from './fetcher'
export type UserDtoImageUrl = { [key: string]: unknown }

export interface UserDto {
  id: string
  email: string
  name: string
  imageUrl: UserDtoImageUrl
  emailVerified: boolean
  role: string
  createdAt: string
  updatedAt: string
}

export interface BrandDto {
  id: string
  name: string
  createdAt: string
  updatedAt: string
}

export interface CreateBrandDto {
  name: string
}

export interface UpdateBrandDto {
  name?: string
}

export interface SourceDto {
  id: string
  name: string
  domain: string
  country: string
  vendorType: string
  trustLevel: string
  createdAt: string
  updatedAt: string
}

export interface CreateSourceDto {
  name: string
  domain: string
  country: string
}

export interface UpdateSourceDto {
  name?: string
  domain?: string
  country?: string
}

export interface ListingDto {
  id: string
  componentId: string
  sourceId: string
  url: string
  available: boolean
  currency: string
  createdAt: string
  updatedAt: string
}

export type CategoryDtoParentCategoryId = { [key: string]: unknown }

export interface CategoryDto {
  id: string
  name: string
  parentCategoryId: CategoryDtoParentCategoryId
  createdAt: string
  updatedAt: string
}

export interface CreateCategoryDto {
  name: string
  parentCategoryId: string
}

export interface UpdateCategoryDto {
  name?: string
  parentCategoryId?: string
}

export type ComponentDtoBrandId = { [key: string]: unknown }

export type ComponentDtoCategoryId = { [key: string]: unknown }

export type ComponentDtoModel = { [key: string]: unknown }

export interface ComponentDto {
  id: string
  name: string
  brandId: ComponentDtoBrandId
  categoryId: ComponentDtoCategoryId
  model: ComponentDtoModel
  tier: string
  createdAt: string
  updatedAt: string
}

export interface CreateComponentDto {
  name: string
  model: string
  tier: string
  description: string
  brandId: string
  sourceId: string
}

export interface UpdateComponentDto {
  name?: string
  model?: string
  tier?: string
  description?: string
  brandId?: string
  sourceId?: string
}

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserRole = {
  user: 'user',
  admin: 'admin',
} as const

export interface UpdateUserDto {
  name: string
  role: UserRole
}

/**
 * Returns OK if the application is running normally.
 * @summary Health check
 */
export const health = (signal?: AbortSignal) => {
  return customAxios<void>({ url: `/health`, method: 'GET', signal })
}

export const getHealthQueryKey = () => {
  return [`/health`] as const
}

export const getHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof health>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof health>>> = ({
    signal,
  }) => health(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof health>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthQueryResult = NonNullable<Awaited<ReturnType<typeof health>>>
export type HealthQueryError = unknown

export function useHealth<
  TData = Awaited<ReturnType<typeof health>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof health>>,
          TError,
          Awaited<ReturnType<typeof health>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealth<
  TData = Awaited<ReturnType<typeof health>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof health>>,
          TError,
          Awaited<ReturnType<typeof health>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealth<
  TData = Awaited<ReturnType<typeof health>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Health check
 */

export function useHealth<
  TData = Awaited<ReturnType<typeof health>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get current logged in user.
 * @summary Current user
 */
export const me = (signal?: AbortSignal) => {
  return customAxios<UserDto>({ url: `/auth/me`, method: 'GET', signal })
}

export const getMeQueryKey = () => {
  return [`/auth/me`] as const
}

export const getMeQueryOptions = <
  TData = Awaited<ReturnType<typeof me>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMeQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) =>
    me(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof me>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>
export type MeQueryError = unknown

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = unknown>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof me>>,
          TError,
          Awaited<ReturnType<typeof me>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = unknown>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof me>>,
          TError,
          Awaited<ReturnType<typeof me>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = unknown>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Current user
 */

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = unknown>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Redirect to Google OAuth.
 * @summary Google OAuth
 */
export const google = (signal?: AbortSignal) => {
  return customAxios<void>({ url: `/auth/google`, method: 'GET', signal })
}

export const getGoogleQueryKey = () => {
  return [`/auth/google`] as const
}

export const getGoogleQueryOptions = <
  TData = Awaited<ReturnType<typeof google>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof google>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGoogleQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof google>>> = ({
    signal,
  }) => google(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof google>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GoogleQueryResult = NonNullable<Awaited<ReturnType<typeof google>>>
export type GoogleQueryError = unknown

export function useGoogle<
  TData = Awaited<ReturnType<typeof google>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof google>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof google>>,
          TError,
          Awaited<ReturnType<typeof google>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGoogle<
  TData = Awaited<ReturnType<typeof google>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof google>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof google>>,
          TError,
          Awaited<ReturnType<typeof google>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGoogle<
  TData = Awaited<ReturnType<typeof google>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof google>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Google OAuth
 */

export function useGoogle<
  TData = Awaited<ReturnType<typeof google>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof google>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGoogleQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Callback for Google OAuth.
 * @summary Google OAuth callback
 */
export const googleCallback = (signal?: AbortSignal) => {
  return customAxios<void>({
    url: `/auth/google/callback`,
    method: 'GET',
    signal,
  })
}

export const getGoogleCallbackQueryKey = () => {
  return [`/auth/google/callback`] as const
}

export const getGoogleCallbackQueryOptions = <
  TData = Awaited<ReturnType<typeof googleCallback>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof googleCallback>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGoogleCallbackQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof googleCallback>>> = ({
    signal,
  }) => googleCallback(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof googleCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GoogleCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof googleCallback>>
>
export type GoogleCallbackQueryError = unknown

export function useGoogleCallback<
  TData = Awaited<ReturnType<typeof googleCallback>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof googleCallback>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof googleCallback>>,
          TError,
          Awaited<ReturnType<typeof googleCallback>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGoogleCallback<
  TData = Awaited<ReturnType<typeof googleCallback>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof googleCallback>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof googleCallback>>,
          TError,
          Awaited<ReturnType<typeof googleCallback>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGoogleCallback<
  TData = Awaited<ReturnType<typeof googleCallback>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof googleCallback>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Google OAuth callback
 */

export function useGoogleCallback<
  TData = Awaited<ReturnType<typeof googleCallback>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof googleCallback>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGoogleCallbackQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Revokes the session and clears the cookie.
 * @summary Logout
 */
export const logout = (signal?: AbortSignal) => {
  return customAxios<void>({ url: `/auth/logout`, method: 'POST', signal })
}

export const getLogoutMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['logout']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logout>>,
    void
  > = () => {
    return logout()
  }

  return { mutationFn, ...mutationOptions }
}

export type LogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof logout>>
>

export type LogoutMutationError = unknown

/**
 * @summary Logout
 */
export const useLogout = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logout>>,
      TError,
      void,
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get all brands.
 * @summary List brands
 */
export const listBrands = (signal?: AbortSignal) => {
  return customAxios<BrandDto[]>({ url: `/brands`, method: 'GET', signal })
}

export const getListBrandsQueryKey = () => {
  return [`/brands`] as const
}

export const getListBrandsQueryOptions = <
  TData = Awaited<ReturnType<typeof listBrands>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listBrands>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListBrandsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listBrands>>> = ({
    signal,
  }) => listBrands(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listBrands>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBrandsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listBrands>>
>
export type ListBrandsQueryError = unknown

export function useListBrands<
  TData = Awaited<ReturnType<typeof listBrands>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBrands>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBrands>>,
          TError,
          Awaited<ReturnType<typeof listBrands>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListBrands<
  TData = Awaited<ReturnType<typeof listBrands>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBrands>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBrands>>,
          TError,
          Awaited<ReturnType<typeof listBrands>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListBrands<
  TData = Awaited<ReturnType<typeof listBrands>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBrands>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List brands
 */

export function useListBrands<
  TData = Awaited<ReturnType<typeof listBrands>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBrands>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListBrandsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new brand.
 * @summary Create brand
 */
export const createBrand = (
  createBrandDto: CreateBrandDto,
  signal?: AbortSignal
) => {
  return customAxios<void>({
    url: `/brands`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createBrandDto,
    signal,
  })
}

export const getCreateBrandMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createBrand>>,
    TError,
    { data: CreateBrandDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createBrand>>,
  TError,
  { data: CreateBrandDto },
  TContext
> => {
  const mutationKey = ['createBrand']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createBrand>>,
    { data: CreateBrandDto }
  > = (props) => {
    const { data } = props ?? {}

    return createBrand(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateBrandMutationResult = NonNullable<
  Awaited<ReturnType<typeof createBrand>>
>
export type CreateBrandMutationBody = CreateBrandDto
export type CreateBrandMutationError = unknown

/**
 * @summary Create brand
 */
export const useCreateBrand = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createBrand>>,
      TError,
      { data: CreateBrandDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createBrand>>,
  TError,
  { data: CreateBrandDto },
  TContext
> => {
  const mutationOptions = getCreateBrandMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get a brand by its id
 * @summary Find brand by id
 */
export const findBrandById = (id: string, signal?: AbortSignal) => {
  return customAxios<BrandDto>({ url: `/brands/${id}`, method: 'GET', signal })
}

export const getFindBrandByIdQueryKey = (id?: string) => {
  return [`/brands/${id}`] as const
}

export const getFindBrandByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findBrandById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findBrandById>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindBrandByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findBrandById>>> = ({
    signal,
  }) => findBrandById(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findBrandById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindBrandByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof findBrandById>>
>
export type FindBrandByIdQueryError = unknown

export function useFindBrandById<
  TData = Awaited<ReturnType<typeof findBrandById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findBrandById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findBrandById>>,
          TError,
          Awaited<ReturnType<typeof findBrandById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindBrandById<
  TData = Awaited<ReturnType<typeof findBrandById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findBrandById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findBrandById>>,
          TError,
          Awaited<ReturnType<typeof findBrandById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindBrandById<
  TData = Awaited<ReturnType<typeof findBrandById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findBrandById>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find brand by id
 */

export function useFindBrandById<
  TData = Awaited<ReturnType<typeof findBrandById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findBrandById>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindBrandByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a brand by id.
 * @summary Update brand
 */
export const updateBrand = (id: string, updateBrandDto: UpdateBrandDto) => {
  return customAxios<void>({
    url: `/brands/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateBrandDto,
  })
}

export const getUpdateBrandMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBrand>>,
    TError,
    { id: string; data: UpdateBrandDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBrand>>,
  TError,
  { id: string; data: UpdateBrandDto },
  TContext
> => {
  const mutationKey = ['updateBrand']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBrand>>,
    { id: string; data: UpdateBrandDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateBrand(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateBrandMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateBrand>>
>
export type UpdateBrandMutationBody = UpdateBrandDto
export type UpdateBrandMutationError = unknown

/**
 * @summary Update brand
 */
export const useUpdateBrand = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBrand>>,
      TError,
      { id: string; data: UpdateBrandDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateBrand>>,
  TError,
  { id: string; data: UpdateBrandDto },
  TContext
> => {
  const mutationOptions = getUpdateBrandMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get all sources
 * @summary List sources
 */
export const listSources = (signal?: AbortSignal) => {
  return customAxios<SourceDto[]>({ url: `/sources`, method: 'GET', signal })
}

export const getListSourcesQueryKey = () => {
  return [`/sources`] as const
}

export const getListSourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof listSources>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListSourcesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listSources>>> = ({
    signal,
  }) => listSources(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSources>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSources>>
>
export type ListSourcesQueryError = unknown

export function useListSources<
  TData = Awaited<ReturnType<typeof listSources>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSources>>,
          TError,
          Awaited<ReturnType<typeof listSources>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListSources<
  TData = Awaited<ReturnType<typeof listSources>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSources>>,
          TError,
          Awaited<ReturnType<typeof listSources>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListSources<
  TData = Awaited<ReturnType<typeof listSources>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List sources
 */

export function useListSources<
  TData = Awaited<ReturnType<typeof listSources>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListSourcesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new source
 * @summary Create source
 */
export const createSource = (
  createSourceDto: CreateSourceDto,
  signal?: AbortSignal
) => {
  return customAxios<void>({
    url: `/sources`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createSourceDto,
    signal,
  })
}

export const getCreateSourceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSource>>,
    TError,
    { data: CreateSourceDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSource>>,
  TError,
  { data: CreateSourceDto },
  TContext
> => {
  const mutationKey = ['createSource']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSource>>,
    { data: CreateSourceDto }
  > = (props) => {
    const { data } = props ?? {}

    return createSource(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateSourceMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSource>>
>
export type CreateSourceMutationBody = CreateSourceDto
export type CreateSourceMutationError = unknown

/**
 * @summary Create source
 */
export const useCreateSource = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSource>>,
      TError,
      { data: CreateSourceDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createSource>>,
  TError,
  { data: CreateSourceDto },
  TContext
> => {
  const mutationOptions = getCreateSourceMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get a source by its id
 * @summary Find source by id
 */
export const findSourceById = (id: string, signal?: AbortSignal) => {
  return customAxios<SourceDto>({
    url: `/sources/${id}`,
    method: 'GET',
    signal,
  })
}

export const getFindSourceByIdQueryKey = (id?: string) => {
  return [`/sources/${id}`] as const
}

export const getFindSourceByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findSourceById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSourceById>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindSourceByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findSourceById>>> = ({
    signal,
  }) => findSourceById(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findSourceById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindSourceByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof findSourceById>>
>
export type FindSourceByIdQueryError = unknown

export function useFindSourceById<
  TData = Awaited<ReturnType<typeof findSourceById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSourceById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findSourceById>>,
          TError,
          Awaited<ReturnType<typeof findSourceById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindSourceById<
  TData = Awaited<ReturnType<typeof findSourceById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSourceById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findSourceById>>,
          TError,
          Awaited<ReturnType<typeof findSourceById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindSourceById<
  TData = Awaited<ReturnType<typeof findSourceById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSourceById>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find source by id
 */

export function useFindSourceById<
  TData = Awaited<ReturnType<typeof findSourceById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSourceById>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindSourceByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a source by id
 * @summary Update source
 */
export const updateSource = (id: string, updateSourceDto: UpdateSourceDto) => {
  return customAxios<void>({
    url: `/sources/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateSourceDto,
  })
}

export const getUpdateSourceMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSource>>,
    TError,
    { id: string; data: UpdateSourceDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSource>>,
  TError,
  { id: string; data: UpdateSourceDto },
  TContext
> => {
  const mutationKey = ['updateSource']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSource>>,
    { id: string; data: UpdateSourceDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateSource(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateSourceMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSource>>
>
export type UpdateSourceMutationBody = UpdateSourceDto
export type UpdateSourceMutationError = unknown

/**
 * @summary Update source
 */
export const useUpdateSource = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSource>>,
      TError,
      { id: string; data: UpdateSourceDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateSource>>,
  TError,
  { id: string; data: UpdateSourceDto },
  TContext
> => {
  const mutationOptions = getUpdateSourceMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get all listings.
 * @summary List listings
 */
export const listListings = (signal?: AbortSignal) => {
  return customAxios<ListingDto[]>({ url: `/listings`, method: 'GET', signal })
}

export const getListListingsQueryKey = () => {
  return [`/listings`] as const
}

export const getListListingsQueryOptions = <
  TData = Awaited<ReturnType<typeof listListings>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listListings>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListListingsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listListings>>> = ({
    signal,
  }) => listListings(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listListings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListListingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listListings>>
>
export type ListListingsQueryError = unknown

export function useListListings<
  TData = Awaited<ReturnType<typeof listListings>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listListings>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listListings>>,
          TError,
          Awaited<ReturnType<typeof listListings>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListListings<
  TData = Awaited<ReturnType<typeof listListings>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listListings>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listListings>>,
          TError,
          Awaited<ReturnType<typeof listListings>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListListings<
  TData = Awaited<ReturnType<typeof listListings>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listListings>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List listings
 */

export function useListListings<
  TData = Awaited<ReturnType<typeof listListings>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listListings>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListListingsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get a listing by its id
 * @summary Find listing by id
 */
export const findListingById = (id: string, signal?: AbortSignal) => {
  return customAxios<ListingDto>({
    url: `/listings/${id}`,
    method: 'GET',
    signal,
  })
}

export const getFindListingByIdQueryKey = (id?: string) => {
  return [`/listings/${id}`] as const
}

export const getFindListingByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findListingById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findListingById>>,
        TError,
        TData
      >
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindListingByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findListingById>>> = ({
    signal,
  }) => findListingById(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findListingById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindListingByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof findListingById>>
>
export type FindListingByIdQueryError = unknown

export function useFindListingById<
  TData = Awaited<ReturnType<typeof findListingById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findListingById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findListingById>>,
          TError,
          Awaited<ReturnType<typeof findListingById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindListingById<
  TData = Awaited<ReturnType<typeof findListingById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findListingById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findListingById>>,
          TError,
          Awaited<ReturnType<typeof findListingById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindListingById<
  TData = Awaited<ReturnType<typeof findListingById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findListingById>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find listing by id
 */

export function useFindListingById<
  TData = Awaited<ReturnType<typeof findListingById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findListingById>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindListingByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get all categories
 * @summary List categories
 */
export const listCategories = (signal?: AbortSignal) => {
  return customAxios<CategoryDto[]>({
    url: `/categories`,
    method: 'GET',
    signal,
  })
}

export const getListCategoriesQueryKey = () => {
  return [`/categories`] as const
}

export const getListCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListCategoriesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listCategories>>> = ({
    signal,
  }) => listCategories(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listCategories>>
>
export type ListCategoriesQueryError = unknown

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List categories
 */

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new category
 * @summary Create category
 */
export const createCategory = (
  createCategoryDto: CreateCategoryDto,
  signal?: AbortSignal
) => {
  return customAxios<void>({
    url: `/categories`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createCategoryDto,
    signal,
  })
}

export const getCreateCategoryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCategory>>,
    TError,
    { data: CreateCategoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryDto },
  TContext
> => {
  const mutationKey = ['createCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCategory>>,
    { data: CreateCategoryDto }
  > = (props) => {
    const { data } = props ?? {}

    return createCategory(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCategory>>
>
export type CreateCategoryMutationBody = CreateCategoryDto
export type CreateCategoryMutationError = unknown

/**
 * @summary Create category
 */
export const useCreateCategory = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCategory>>,
      TError,
      { data: CreateCategoryDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryDto },
  TContext
> => {
  const mutationOptions = getCreateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get a category by its id
 * @summary Find category by id
 */
export const findCategoryById = (id: string, signal?: AbortSignal) => {
  return customAxios<CategoryDto>({
    url: `/categories/${id}`,
    method: 'GET',
    signal,
  })
}

export const getFindCategoryByIdQueryKey = (id?: string) => {
  return [`/categories/${id}`] as const
}

export const getFindCategoryByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findCategoryById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findCategoryById>>,
        TError,
        TData
      >
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindCategoryByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findCategoryById>>
  > = ({ signal }) => findCategoryById(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findCategoryById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindCategoryByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof findCategoryById>>
>
export type FindCategoryByIdQueryError = unknown

export function useFindCategoryById<
  TData = Awaited<ReturnType<typeof findCategoryById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findCategoryById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCategoryById>>,
          TError,
          Awaited<ReturnType<typeof findCategoryById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindCategoryById<
  TData = Awaited<ReturnType<typeof findCategoryById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findCategoryById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCategoryById>>,
          TError,
          Awaited<ReturnType<typeof findCategoryById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindCategoryById<
  TData = Awaited<ReturnType<typeof findCategoryById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findCategoryById>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find category by id
 */

export function useFindCategoryById<
  TData = Awaited<ReturnType<typeof findCategoryById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findCategoryById>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindCategoryByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a category by id
 * @summary Update category
 */
export const updateCategory = (
  id: string,
  updateCategoryDto: UpdateCategoryDto
) => {
  return customAxios<void>({
    url: `/categories/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateCategoryDto,
  })
}

export const getUpdateCategoryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { id: string; data: UpdateCategoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryDto },
  TContext
> => {
  const mutationKey = ['updateCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCategory>>,
    { id: string; data: UpdateCategoryDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateCategory(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCategory>>
>
export type UpdateCategoryMutationBody = UpdateCategoryDto
export type UpdateCategoryMutationError = unknown

/**
 * @summary Update category
 */
export const useUpdateCategory = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCategory>>,
      TError,
      { id: string; data: UpdateCategoryDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryDto },
  TContext
> => {
  const mutationOptions = getUpdateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get all components
 * @summary List components
 */
export const listComponents = (signal?: AbortSignal) => {
  return customAxios<ComponentDto[]>({
    url: `/components`,
    method: 'GET',
    signal,
  })
}

export const getListComponentsQueryKey = () => {
  return [`/components`] as const
}

export const getListComponentsQueryOptions = <
  TData = Awaited<ReturnType<typeof listComponents>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listComponents>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListComponentsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listComponents>>> = ({
    signal,
  }) => listComponents(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listComponents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListComponentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listComponents>>
>
export type ListComponentsQueryError = unknown

export function useListComponents<
  TData = Awaited<ReturnType<typeof listComponents>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listComponents>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listComponents>>,
          TError,
          Awaited<ReturnType<typeof listComponents>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListComponents<
  TData = Awaited<ReturnType<typeof listComponents>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listComponents>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listComponents>>,
          TError,
          Awaited<ReturnType<typeof listComponents>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListComponents<
  TData = Awaited<ReturnType<typeof listComponents>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listComponents>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List components
 */

export function useListComponents<
  TData = Awaited<ReturnType<typeof listComponents>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listComponents>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListComponentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new component
 * @summary Create component
 */
export const createComponent = (
  createComponentDto: CreateComponentDto,
  signal?: AbortSignal
) => {
  return customAxios<void>({
    url: `/components`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createComponentDto,
    signal,
  })
}

export const getCreateComponentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createComponent>>,
    TError,
    { data: CreateComponentDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createComponent>>,
  TError,
  { data: CreateComponentDto },
  TContext
> => {
  const mutationKey = ['createComponent']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createComponent>>,
    { data: CreateComponentDto }
  > = (props) => {
    const { data } = props ?? {}

    return createComponent(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateComponentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createComponent>>
>
export type CreateComponentMutationBody = CreateComponentDto
export type CreateComponentMutationError = unknown

/**
 * @summary Create component
 */
export const useCreateComponent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createComponent>>,
      TError,
      { data: CreateComponentDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createComponent>>,
  TError,
  { data: CreateComponentDto },
  TContext
> => {
  const mutationOptions = getCreateComponentMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get a component by its id
 * @summary Find component by id
 */
export const findComponentById = (id: string, signal?: AbortSignal) => {
  return customAxios<ComponentDto>({
    url: `/components/${id}`,
    method: 'GET',
    signal,
  })
}

export const getFindComponentByIdQueryKey = (id?: string) => {
  return [`/components/${id}`] as const
}

export const getFindComponentByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findComponentById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findComponentById>>,
        TError,
        TData
      >
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindComponentByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findComponentById>>
  > = ({ signal }) => findComponentById(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findComponentById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindComponentByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof findComponentById>>
>
export type FindComponentByIdQueryError = unknown

export function useFindComponentById<
  TData = Awaited<ReturnType<typeof findComponentById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findComponentById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findComponentById>>,
          TError,
          Awaited<ReturnType<typeof findComponentById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindComponentById<
  TData = Awaited<ReturnType<typeof findComponentById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findComponentById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findComponentById>>,
          TError,
          Awaited<ReturnType<typeof findComponentById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindComponentById<
  TData = Awaited<ReturnType<typeof findComponentById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findComponentById>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Find component by id
 */

export function useFindComponentById<
  TData = Awaited<ReturnType<typeof findComponentById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findComponentById>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindComponentByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a component by id
 * @summary Update component
 */
export const updateComponent = (
  id: string,
  updateComponentDto: UpdateComponentDto
) => {
  return customAxios<void>({
    url: `/components/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateComponentDto,
  })
}

export const getUpdateComponentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateComponent>>,
    TError,
    { id: string; data: UpdateComponentDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateComponent>>,
  TError,
  { id: string; data: UpdateComponentDto },
  TContext
> => {
  const mutationKey = ['updateComponent']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateComponent>>,
    { id: string; data: UpdateComponentDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateComponent(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateComponentMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateComponent>>
>
export type UpdateComponentMutationBody = UpdateComponentDto
export type UpdateComponentMutationError = unknown

/**
 * @summary Update component
 */
export const useUpdateComponent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateComponent>>,
      TError,
      { id: string; data: UpdateComponentDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateComponent>>,
  TError,
  { id: string; data: UpdateComponentDto },
  TContext
> => {
  const mutationOptions = getUpdateComponentMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Get all users.
 * @summary List users
 */
export const listUsers = (signal?: AbortSignal) => {
  return customAxios<UserDto[]>({ url: `/users`, method: 'GET', signal })
}

export const getListUsersQueryKey = () => {
  return [`/users`] as const
}

export const getListUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({
    signal,
  }) => listUsers(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof listUsers>>
>
export type ListUsersQueryError = unknown

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List users
 */

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get user by id.
 * @summary Get user by id
 */
export const findUserById = (id: string, signal?: AbortSignal) => {
  return customAxios<UserDto>({ url: `/users/${id}`, method: 'GET', signal })
}

export const getFindUserByIdQueryKey = (id?: string) => {
  return [`/users/${id}`] as const
}

export const getFindUserByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findUserById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findUserById>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindUserByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findUserById>>> = ({
    signal,
  }) => findUserById(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findUserById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindUserByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof findUserById>>
>
export type FindUserByIdQueryError = unknown

export function useFindUserById<
  TData = Awaited<ReturnType<typeof findUserById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findUserById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findUserById>>,
          TError,
          Awaited<ReturnType<typeof findUserById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindUserById<
  TData = Awaited<ReturnType<typeof findUserById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findUserById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findUserById>>,
          TError,
          Awaited<ReturnType<typeof findUserById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindUserById<
  TData = Awaited<ReturnType<typeof findUserById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findUserById>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get user by id
 */

export function useFindUserById<
  TData = Awaited<ReturnType<typeof findUserById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findUserById>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindUserByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update user by id.
 * @summary Update user by id
 */
export const updateUser = (id: string, updateUserDto: UpdateUserDto) => {
  return customAxios<UserDto>({
    url: `/users/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateUserDto,
  })
}

export const getUpdateUserMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: string; data: UpdateUserDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserDto },
  TContext
> => {
  const mutationKey = ['updateUser']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { id: string; data: UpdateUserDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateUser(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>
export type UpdateUserMutationBody = UpdateUserDto
export type UpdateUserMutationError = unknown

/**
 * @summary Update user by id
 */
export const useUpdateUser = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { id: string; data: UpdateUserDto },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserDto },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
